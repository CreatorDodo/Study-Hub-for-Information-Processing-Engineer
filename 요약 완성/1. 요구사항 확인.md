# 소프트웨어 개발 방법론

## **★** 애자일(Agile)

- 개념: 절차보다는 사람이 중심이 되어 변화에 유연하고 신속하게 적응하면서 효율적으로 시스템을 개발할 수 있는 신속 적응적 경량 개발 방법론이다.
- 짧고 신속, 즉시 피드백, 유동적 개발.
- 유형: XP, 린(Lean), 스크럼(SCRUM) 등.

## **★** XP

- 1 ~ 3주의 반복(Iteration) 개발주기.
- 5가지 가치와 12개의 실천항목이 존재.

### **★** XP의 5가지 가치

1. 용기
2. 단순성
3. 의사소통
4. 피드백
5. 존중

### **★** XP의 12가지 기본원리

1. 짝 프로그래밍
2. 공동 코드 소유
3. 지속적인 통합
4. 계획 세우기
5. 작은 릴리즈
6. 메타포어
7. 간단한 디자인
8. 테스트 기반 개발
9. 리팩토링
10. 40시간 작업
11. 고객 상주
12. 코드 표준.

## **★** 스크럼(SCRUM)

- 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 팀을 위한 프로젝트 관리 중심 개발론.

### **★** 스크럼의 주요개념

1. 백로그
2. 스프린트
3. 스크럼 미팅
4. 스크럼 마스터
5. 스프린트 회고
6. 번 다운 차트

## **★** 린(Lean)

- 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상시킨 방법론.
- JIT(Just In Time), 칸반(Kanban) 보드 사용.

### **★** 린(Lean)의 7가지 원칙

1. 낭비제거
2. 품질 내재화
3. 지식 창출
4. 늦은 확정
5. 빠른 인도
6. 사람 존중
7. 전체 최적화

## 객체 지향 분석 방법론

### **★** 객체 지향 설계 원칙(SOLID)

1. 단일 책임의 원칙(SRP)

- 하나의 클래스는 하나의 목적을 위해서 생성되며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어 있어야 한다는 원칙.

2. 개방 폐쇠 원칙(OCP)

- 소프트웨어의 구성요소(컴포넌트, 클래스, 모듈, 함수)는 확장에는 열려 있고, 변경에는 닫혀있어야 한다는 원칙.

3. 리스코프 치환의 원칙(LSP)

- 서브 타입(상속받은 하위 클래스)은 어디서나 자신의 기반 타입(상위 클래스)으로 교체할 수 있어야 한다는 원칙.

4. 인터페이스 분리의 원칙(ISP)

- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙.
- 객체 설계 시 특정 기능에 대한 인터페이스는 그 기능과 상관없는 부분이 변해도 영향을 받지 않아야 한다는 원칙.

5. 의존성 역전의 원칙(DIP)

- 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙.

### **★** 객체 지향 분석 방법론 종류

1. OOSE[야콥슨]

- 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용하는 방법론.
- 분석, 설계, 구현 단계로 구성.
- 기능적 요구사항 중심의 시스템.

2. OMT[럼바우]

- 그래픽 표기법을 이용하여 소프트웨어 구성요소를 모델링하는 방법론.
- 분석 절차는 객체 모델링 → 동적 모델링 → 기능 모델링 순서로 진행.
- 객체 모델링(Object Modeling) : 정보 모델링이라고도 함, ER 다이어그램을 만드는 과정까지의 모델링, **객체 다이어그램을 활용하여 표현.**
- 동적 모델링(Dynamic Modeling) : 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현하는 모델링, **상태 다이어그램을 활용하여 표현.**
- 기능 모델링(Functional Modeling) : 프로세스들의 자료 흐름을 중심으로 처리 과정 표현하는 모델링, **자료 흐름도(DFD)를 활용하여 표현.**

3. OOD[부치]

- 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론.
- 분석과 설계의 분리가 불가능.
- 분석하는 데 이용된 객체 모델의 설계 시 적용.

## 프로젝트 관리

### **★** Man Month 모형

- Man Month = LoC / 프로그래머의 월간 생산성
- 프로젝트 기간 = Man Month / 프로젝트 인력

# 현행 시스템 분석

## 디자인 패턴

### **★** 디자인 패턴 유형

1. 목적

- 생성 : 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴.
- 구조 : 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴.
- 행위 : 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴.

2. 범위

- 클래스 : 클래스 간 관련성(상속 관계를 다루는 패턴). 컴파일 타임에 정적으로 결정.
- 객체 : 객체 간 관련성을 다루는 패턴.
  런타임에 동적으로 결정.

### **★** 디자인 패턴 종류

1. 생성 패턴

- Builder : 복잡한 인스턴스를 조립하여 만드는 구조, 객체를 생성하는 방법(과정)과 객체를 구현(표현)하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴.[생성과 표기를 분리해서 복잡한 객체를 생성.]
- Prototype : 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴[기존 객체를 복제함으로써 객체를 생성.]
- Factory Method : 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 하는 방식[생성할 객체의 클래스를 국한하지 않고 객체를 생성.]
- Abstract Factory : 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴[동일한 주제의 다른 팩토리를 묶음.]
- Singleton : 전역 변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 하는 디자인 패턴[한 클래스에서 한 객체만 존재하도록 제한.]

2. 구조 패턴

- Bridge : 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴[구현뿐만 아니라, 추상화된 부분까지 변경해야 하는 경우 활용]
- Decorator : 기존에 구현되어 있는 클래스에 필요한 기능을 추가해 나가는 설계 패턴[객체의 결합을 통해 기능을 동적으로 유연하게 확장]
- Facade : 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간 또는 여타 시스템과의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴[통합된 인터페이스 제공]
- Flyweight : 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스 화하여 공유함으로써 메모리를 절약하고, '클래스의 경량화'를 목적으로 하는 디자인 패턴[여러 개의 '가상 인스턴스'를 제공하여 메모리 절감]
- Ploxy : '실체 객체에 대한 대리 객체'로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 정보은닉의 역할도 수행하는 디자인 패턴[특정 객체로의 접근을 제어하기 위한 용도로 사용]
- Composite : 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴[복합 객체와 단일 객체를 동일하게 취급]
- Adapter : 기존에 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴[인터페이스가 호환되지 않는 클래스들을 함께 이용할 수 있도록 타 클래스의 인터페이스를 기존 인터페이스에 덧씌움]

3. 행위 패턴

- Mediator : 객체 지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체 지향에서 가장 중요한 느슨한 결합의 특성을 해칠 수 있기 때문에 이를 해결하는 방법으로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고 중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여 객체 지향 목표를 달성하게 해주는 디자인 패턴[상호 작용의 유연한 변경을 지원]
- Interpreter : 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 디자인 패턴[문법 자체를 캡슐화하여 사용]
- Iterator : 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 반복자(Iterator)를 사용하여 접근할 수 있는 디자인 패턴[내부구조를 노출하지 않고, 복잡 객체의 원소를 순차적으로 접근 가능하게 해주는 행위 패턴]
- Template Method : 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴, 일반적으로 상위 클래스(추상 클래스)에는 추상 메서드를 통해 기능의 골격을 제공하고, 하위 클래스(구체 클래스)의 메서드에는 세부 처리를 구체화하는 방식으로 사용[상위 작업의 구조를 바꾸지 않으면서 서브 클래스로 작업의 일부분을 수행]
- Observer : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에 연락이 가고 자동으로 내용이 갱신되는 방법으로 일대 다의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴[객체의 상태 변화에 따라 다른 객체의 상태도 연동, 일대다 의존]
- State : 객체 상태를 캡슐화하여 클래스화함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경[객체의 상태에 따라 행위 내용을 변경]
- Visitor : 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴[특정 구조를 이루는 복합 객체의 원소 특성에 따라 동작을 수행할 수 있도록 지원하는 행위]
- Command : 실행될 기능을 캡슐화함을써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴으로 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브 클래스가 선택되어 실행되는 특징을 갖는 디자인 패턴[요구사항을 객체로 캡슐화]
- Strategy : 알고리즘 군을 정의하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴으로, 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 디자인 패턴[행위 객체를 클래스로 캡슐화해 동적으로 행위를 자유롭게 변환]
- Memento : 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴으로 Undo 기능을 개발할 때 사용하는 디자인 패턴[객체를 이전 상태로 복구시켜야 하는 경우, '작업 취소(Undo)' 요청 가능]
- Chain of Responsibility : 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능한데, 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 디자인 패턴[한 요청을 2개 이상의 객체에서 처리]

## 개발 기술 환경 정의

### **★** 운영체제 종류 및 특징

1. PC

- 윈도즈(Windows)[Microsoft] : [중/소규모 서버, 일반 PC] 등 유지, 관리 비용 장점
- 유닉스(UNIX)[IBM, HP, SUN] : 대용량 처리, 안정성 높은 엔터프라이즈급 서버
- 리눅스(Linux)[Linus Torvalds] : 중/대규모 서버 대상, 높은 보안성 제공

2. 모바일

- 안드로이드(Android)[Google] : 리눅스 운영체제 위에서 구동하며 휴대폰 전화를 비롯한 휴대용 장치를 위한 운영체제와 미들웨어, 사용자 인터페이스 그리고 표준 응용 프로그램(웹 브라우저, 이메일 클라이언트, 단문 메시지 서비스(SMS), MMS) 등을 포함하고 있는 소프트웨어 스택이자 리눅스 모바일 운영체제[개발자들이 자바, 코틀린 언어로 응용 프로그램을 작성할 수 있게 했고, 컴파일된 바이트 코드를 구동할 수 있는 런타임 라이브러리를 제공하는 운영체제]
- iOS[Apple] : 스마트폰, 태플릿PC의 높은 보안성과 고성능 제공

※ 리눅스(Linux) 기반 시스템이 하드웨어 및 소프트웨어 소유 비용이 가장 적게 소요된다.

# 요구사항 확인

## **★** 요구사항의 분류

1. 기능적 요구사항

- 개념 : 시스템이 제공하는 기능, 서비스에 대한 요구사항.
- 예시 : [상품의 결제수단은 신용카드, 무통장 입금, 포인트 결제가 가능해야 함.]

2. 비기능적 요구사항

- 개념 : 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항에 관한 요구사항.
- 예시 : [특정 함수의 호출시간은 3초를 넘지 않아야 함, 시스템은 하루 24시간 가동되어야 하며 가동률 99.5%를 만족해야 함]

## **★** 요구사항 확인 및 검증 단계의 주요 기법.

### 정형 기술 검토 활용

1. 동료 검토(Peer Review) : 2~3명이 진행하는 리뷰의 형태[요구사항 명세서 작성자가 요구사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견하는 형태로 진행하는 검토 방법]
2. 워크 스루(Walk Through) : 오류를 조기에 검출하는 데 목적이 있는 검토 방법[검토 자료를 회의 전에 배포해서 사전검토한 후 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 오류를 검출하고 문서화하는 비공식적인 검토 방법]
3. 인스펙션(Inspection) : 소프트웨어 요구, 설계, 원시 코드 등의 저작자 외의 다른 전문가 또는 팀이 검사하여 오류를 찾아내는 공식적인 검토 방법[인스펙션 절차는 계획 → 사전 교육 → 준비 → 인스펙션 회의 → 수정 → 후속 조치 순서로 진행]
