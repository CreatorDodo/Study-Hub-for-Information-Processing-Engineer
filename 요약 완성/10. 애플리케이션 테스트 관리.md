# 애플리케이션 테스트 케이스 설계

### **★** 소프트웨어 테스트의 원리

- 결함 존재 증명
  - 결함이 존재함을 밝히는 활동.
  - 결함이 없다는 것을 증명할 수는 없음.
  - 결함을 줄이는 활동.
- 완벽 테스팅은 불가능
  - 완벽하게 테스팅하려는 시도는 불필요한 시간과 자원낭비.
  - 무한 경로(한 프로그램 내의 내부 조건은 무수히 많을 수 있음), 무한 입력값(입력이 가질 수 있는 모든 값의 조합이 무수히 많음)으로 인한 테스트 어려움.
- 초기 집중
  - 조기 테스트 설계 시 장점: 테스팅 결과를 단시간에 알 수 있고, 테스팅 기간 단축, 재작업을 줄여 개발 기간 단축 및 결함 예방.
  - SW 개발 초기 체계적인 분석 및 설계가 수행되지 못하면 그 결과가 프로젝트 후반에 영향을 미치게 되어 비용이 커진다는 요르돈의 법칙 적용(Snowball Effect, 눈덩이 법칙)
- 결함 집중
  - 적은 수의 모듈에서 대다수의 결함이 발견됨.
  - 소프트웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견.
  - 파레토 법칙(Pareto Principle)의 내용인 80 대 20 법칙 적용.
- 살충제 패러독스
  - 동일한 테스트 케이스에 의한 반복적 테스트는 새로운 버그를 찾지 못함.
  - 테스트 케이스의 정기적 리뷰와 개선 및 다른 시각에서의 접근이 필요.
- 정황 의존성
  - 소프트웨어의 성격에 맞게 테스트 실시.
  - 정황과 비즈니스 도메인에 따라 테스트를 다르게 수행.
- 오류-부재의 궤변
  - 요구사항을 충족시켜주지 못한다면, 결함이 없다고 해도 품질이 높다고 볼 수 없음.

### **★** 화이트박스 테스트

- 구문 커버리지 = 문장 커버리지(Statement Coverage)
  - 구문 커버리지는 프로그램 내의 모든 명령문을 적어도 한 번 수행하는 커버리지.
  - 조건문 결과와 관계없이 구문 실행 개수로 계산.
- 결정 커버리지 = 선택 커버리지(Decision Coverage) = 분기 커버리지(Branch Coverage)
  - 결정 커버리지는 (각 분기의) 결정 포인트 내의 전체 조건식이 적어도 한 번은 참(T)과 거짓(F)의 결과를 수행하는 테스트 커버리지.
  - 구문 커버리지를 포함.
- 조건 커버리지(Condition Coverage)
  - 조건 커버리지는 (각 분기의) 결정 포인트 내의 각 개별 조건식이 적어도 한 번은 참과 거짓의 결과가 되도록 수행하는 테스트 커버리지.
  - 구문 커버리지를 포함.
- 조건/결정 커버리지(Condition/Decision Coverage)
  - 조건/결정 커버리지는 전체 조건식뿐만 아니라 개별 조건식도 참 한번, 거짓 한 번 결과가 되도록 수행하는 테스트 커버리지.
- 변경 조건/결정 커버리지(Modified Condition/Decision Coverage)
  - 변경 조건/결정 커버리지는 개별 조건식이 다른 개별 조건식에 영향을 받지 않고 전체 조건식에 독립적으로 영향을 주도록 함으로써 조건/결정 커버리지를 향상시킨 커버리지.
- 다중 조건 커버리지(Multiple Condition Coverage)
  - 다중 조건 커버리지는 결정 조건 내 모든 개별 조건식의 모든 가능한 조합을 100% 보장하는 커버리지.
- 기본 경로 커버리지 = 경로 커버리지(Base Path Coverage)
  - 기본 경로 커버리지는 수행 가능한 모든 경로를 테스트하는 기법.
- 제어 흐름 테스트(Control Flow Testing)
  - 제어 흐름 테스트는 프로그램 제어 구조를 그래프 형태로 나타내어 내부 로직을 테스트하는 기법.
- 데이터 흐름 테스트(Data Flow Testing)
  - 데이터 흐름 테스트는 제어 흐름 그래프에 데이터 사용현황을 추가한 그래프를 통해 테스트하는 기법.
- 루프 테스트(Loop Testing)
  - 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 기법.

### **★** 블랙박스 테스트

- 동등분할 테스트 = 동치 분할 테스트, 균등 분할 테스트, 동치 클래스 분해 테스트(Equivalence Partitioning Testing)
  - 입력 데이터의 영역을 유사한 도메인별로 유효값/무효값을 그룹핑하여 대푯값 테스트 케이스를 도출하여 테스트하는 기법.
- 경곗값 분석 테스트 = 한곗값 테스트(Boundary Value Analysis Testing)
  - 등가 분할 후 경계값 부분에서 오류 발생 확률이 높기 때문에 경곗값을 포함하여 테스트 케이스를 설계하여 테스트하는 기법.
  - 최솟값 바로 위, 최대치 바로 아래 등 입력값의 극한 한계를 테스트하는 기법.
- 결정 테이블 테스트(Decision Table Testing)
  - 요구사항의 논리와 발생조건을 테이블 형태로 나열하여, 조건과 행위를 모두 조합하여 테스트하는 기법.
- 상태 전이 테스트(State Transition Testing)
  - 테스트 대상 \* 시스템이나 객체의 상태를 구분하고, 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 수행하는 테스트 기법.
- 유스케이스 테스트(Use Case Testing)
  - 시스템이 실제 사용되는 유스케이스로 모델링 되어 있을 때 프로세스 흐름을 기반으로 테스트 케이스를 명세화하여 수행하는 테스트 기법.
- 분류 트리 테스트(Classification Tree Method Testing)
  - SW의 일부 또는 전체를 트리 구조로 분석 및 표현하여 테스트 케이스를 설계하여 테스트하는 기법.
- 페어와이즈 테스트(Pairwise Testing)
  - 테스트 데이터값들 간에 최소한 한 번씩을 조합하는 방식이며, 이는 커버해야 할 기능적 범위를 모든 조합에 비해 상대적으로 적은 양의 테스트 세트를 구성하기 위한 테스트 기법.
- 원인-결과 그래프 테스트(Cause-Effect Graph Testing)
  - 그래프를 활용하여 입력 데이터 간의 관계 및 출력에 미치는 영향을 분석하여 효용성이 높은 테스트 케이스를 선정하여 테스트하는 기법.
- 비교 테스트(Comparison Testing)
  - 여러 버전의 프로그램에 같은 입력값을 넣어서 동일한 결과 데이터가 나오는지 비교해 보는 테스트 기법.
- 오류 추정 테스트(Error Guessing Testing)
  - 개발자가 범할 수 있는 실수를 추정하고 이에 따른 결함이 검출되도록 테스트 케이스를 설계하여 테스트하는 기법.
  - 특정 테스트 대상이 주어지면 테스터의 경험과 직관을 바탕으로 개발자가 범할 수 있는 실수들을 나열하고, 해당 실수에 따른 결함을 노출하는 테스트로 다른 블랙박스 테스트 기법을 보완할 때 사용하는 기법.

### **★** 테스트 목적에 따른 분류

- 회복 테스트(Recovery Testing)
  - 시스템에 고의로 실패를 유도하고, 시스템의 정상적 복귀 여부를 테스트하는 기법.
- 안전 테스트(Security Testing)
  - 불법적인 소프트웨어가 접근하여 시스템을 파괴하지 못하도록 소스 코드 내의 보안적인 결함을 미리 점검하는 테스트 기법.
- 성능 테스트(Performance Testing)
  - 사용자의 이벤트에 시스템이 응답하는 시간, 특정 시간 내에 처리하는 업무량, 사용자 요구에 시스템이 반응하는 속도 등을 측정하는 테스트 기법.
- 구조 테스트(Structure Testing)
  - 시스템의 내부 논리 경로, 소스 코드의 복잡도를 평가하는 테스트 기법.
- 회귀 테스트(Regression Testing)
  - 회귀 테스트는 오류를 제거하거나 수정한 시스템에서 오류 제거와 수정에 의해 새로이 유입된 오류가 없는지 확인하는 일종의 반복 테스트 기법.
- 병행 테스트(Parallel Testing)
  - 변경된 시스템과 기존 시스템에 동일한 데이터를 입력 후 결과를 비교하는 테스트 기법.

### **★** 성능 테스트의 상세 유형

- 부하 테스트(Load Testing)
  - 시스템에 부하를 계속 증가시키면서 시스템의 임계점을 찾는 테스트.
  - 부하 테스트를 통해 병목 지점을 찾아서 병목 현상을 제거하는 과정을 반복.
- 강도 테스트(Stress Testing)
  - 시스템 처리 능력 이상의 부하, 즉 임계점 이상의 부하를 가하여 비정상적인 상황에서 시스템의 동작 상태를 확인하는 테스트.
- 스파이크 테스트(Spike Testing)
  - 짧은 시간에 사용자가 몰릴 때 시스템의 반응 측정 테스트.
- 내구성 테스트(Endurance Testing)
  - 오랜 시간 동안 시스템에 높은 부하를 가하여 시스템 반응 테스트.

### **★** 정적 분석(Static Analysis)

- 리뷰는 사람이 직접 수행하는 수작업 중심의 방법이지만, 정적 분석은 도구의 지원을 받아 정적 테스트를 수행하는 방법이다.
- 정적 분석은 자동화된 도구를 이용하여 산출물의 결함을 검출하거나 복잡도를 측정한다.
- 정적 분석으로는 코딩 표준 부합, 코드 복잡도 계산, 자료 흐름 분석 등이 있다.

### **★** 테스트 케이스 필요 항목

#### 공통 작성 항목 요소

- 테스트 단계명, 작성자, 승인자, 작성 일자, 문서 버전
  - 단위/통합/시스템/인수 테스트 등의 테스트 단계와 테스트 케이스 작성자, 승인자, 작성 일자, 버전 등을 작성.
- 대상 시스템
  - 애플리케이션 개발 서버 또는 개발 시스템명 등을 작성.
- 변경 여부
  - 테스트 케이스 변경 여부 및 변경 사유 등을 작성.
- 테스트 범위
  - 테스트 대상 애플리케이션의 기능별 테스트 범위 및 업무별 테스트 범위를 식별.
- 테스트 조직
  - 테스트 케이스 작성 및 테스트 수행을 담당할 조직 식별.

#### 개별 테스트 케이스 항목 요소

- 테스트 ID
  - 테스트 케이스를 고유하게 식별하기 위한 ID를 작성.
- 테스트 목적
  - 테스트 시 고려해야 할 중점 사항이나 테스트 케이스의 목적을 작성.
- 테스트할 기능
  - 애플리케이션의 테스트할 기능을 간략하게 작성.
- 테스트 데이터(= 입력 데이터)
  - 테스트 실행 시 입력할 데이터(입력값, 선택 버튼, 체크리스트 값 등)를 작성.
- 예상 결과(= 기대 결과)
  - 테스트 실행 후 기대되는 결과 데이터(출력 데이터, 결과 화면, 기대 동작 등)를 작성.
- 테스트 환경
  - 테스트 시 사용할 물리적, 논리적 테스트 환경, 사용할 데이터, 결과 기록 서버 등의 내용을 작성.
- 테스트 조건(= 전제 조건)
  - 테스트 간의 종속성, 테스트 수행 전 실행되어야 할 고려사항 등을 작성.
- 성공/실패 기준
  - 테스트를 거친 애플리케이션 기능의 성공과 실패를 판단하는 조건을 명확하게 작성.
- 기타 요소
  - 사용자의 테스트 요구사항 중 특별히 고려해야 할 내용을 간략하게 기술.

### **★** 테스트 오라클

#### 테스트 오라클(Test Oracle)의 개념

- 테스트 오라클은 테스트의 결과가 참인지 거짓인지를 판단하기 위해서 사전에 정의된 참값을 입력하여 비교하는 기법이다.

#### 테스트 오라클 종류

- 참(True) 오라클
  - 모든 입력값에 대하여 기대하는 결과를 생성함으로써 발생된 오류를 모두 검출할 수 있는 오라클.
- 샘플링(Sampling) 오라클
  - 특정한 몇 개의 입력값에 대해서만 기대하는 결과를 제공해 주는 오라클.
- 휴리스틱(Heuristic) 오라클
  - 샘플링 오라클을 개선한 오라클로, 특정 입력값에 대해 올바른 결과를 제공하고, 나머지 값들에 대해서는 휴리스틱(추정)으로 처리하는 오라클.
- 일관성 검사(Consistent) 오라클
  - 애플리케이션 변경이 있을 때, 수행 전과 후의 결괏값이 동일한지 확인하는 오라클.

### **★** 테스트 레벨 종류

- 단위 테스트
  - 사용자 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트하는 단계.
  - 자료 구조 테스트, 실행 경로 테스트, 오류 처리 테스트, 인터페이스 테스트.
- 통합 테스트
  - 단위 테스트를 통과한 모듈 사이의 인터페이스, 통합된 컴포넌트 간의 상호 작용을 검증하는 테스트 단계.
  - 빅뱅 테스트, 샌드위치 테스트, 상향식 테스트,하향식 테스트.
- 시스템 테스트
  - 통합된 단위 시스템의 기능이 시스템에서 정상적으로 수행되는지를 검증하는 테스트 단계.
  - 기능 \* 비기능 요구사항 테스트.
- 인수 테스트
  - 계약상의 요구사항이 만족되었는지 확인하기 위한 테스트 단계.
  - 계약 인수, 규정 인수, 사용자 인수, 운영상의 인수, 알파 \* 베타 테스트.

### **★** 인수 테스트

- 알파 테스트(Alpha Test)
  - 선택된 사용자(회사 내의 다른 사용자 또는 실제 사용자)가 개발자 환경에서 통제된 상태로 개발자와 함께 수행하는 인수 테스트.
- 베타 테스트(Beta Test)
  - 실제 환경에서 일정 수의 사용자에게 대상 소프트웨어를 사용하게 하고 피드백을 받는 인수 테스트.

# 애플리케이션 통합 테스트

### **★** 상향식 통합

#### 상향식 통합(Bottom Up) 개념

- 애플리케이션 구조에서 최하위 레벨의 모듈 또는 컴포넌트로부터 위쪽 방향으로 제어의 경로를 따라 이동하면서 구축과 테스트를 수행한다.

#### 상향식 통합 수행 단계

**1단계** : 하위 레벨의 모듈 또는 컴포넌트들이 하위 모듈의 기능을 수행하는 클러스터(Cluster)로 결합.

**2단계** : 상위의 모듈에서 데이터의 입력과 출력을 확인하기 위한 더미 모듈인 드라이버 작성.

**3단계** : 각 통합된 클러스터 단위 테스트.

**4단계** : 테스트가 완료되면 각 클러스터들은 프로그램의 위쪽으로 결합되며, 드라이버는 실제 모듈 또는 컴포넌트로 대체.

### **★** 정적 분석 도구(Static Analysis Tools)

- 정적 분석 도구는 만들어진 애플리케이션을 실행하지 않고 분석하는 도구이다.

* 대부분의 경우 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함을 발견하기 위하여 사용한다.
* 테스트를 수행하는 사람이 작성된 소스 코드에 대한 이해를 바탕으로 도구를 이용해서 분석하는 것을 말한다.

### **★** 테스트 하네스

#### 테스트 하네스(Test Harness) 개념

- 애플리케이션 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위한 코드와 데이터를 말하며, 단위 또는 모듈 테스트에 사용하기 위해 코드 개발자가 작성한다.

#### 테스트 하네스 구성요소

- 테스트 드라이버(Test Driver)
  - 테스트 대상 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 등 상향식 테스트의 필요.
- 테스트 스텁(Test Stub)
  - 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로 하향식 테스트에 필요.
- 테스트 슈트(Test Suites)
  - 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합.
- 테스트 케이스(Test Case)
  - 입력값, 실행 조건, 기대 결과 등의 집합.
- 테스트 시나리오(Test Scenario)
  - 애플리케이션의 테스트 되어야 할 기능 및 특징, 테스트가 필요한 상황을 작성한 문서.
  - 하나의 단일 테스트 시나리오가 하나 또는 여러 개의 테스트 케이스들을 포함할 수 있음.
- 테스트 스크립트(Test Script)
  - 자동화된 테스트 실행 절차에 대한 명세.
- 목 오브젝트(Mock Object)
  - 사용자의 행위를 조건부로 사전에 입력해 두면, 그 상황에 예정된 행위를 수행하는 객체.

# 애플리케이션 성능 개선

### **★** 애플리케이션 성능 측정 지표

- 처리량(Throughput)
  - 애플리케이션이 주어진 시간에 처리할 수 있는 트랜잭션의 수.
  - 웹 애플리케이션의 경우 시간당 페이지 수로 표현.
- 응답 시간(Response Time)
  - 사용자 입력이 끝난 후, 애플리케이션의 응답 출력이 개시될 때까지의 시간.
  - 애플리케이션의 경우 메뉴 클릭 시 해당 메뉴가 나타나기까지 걸리는 시간.
- 경과 시간(Turnaround Time)
  - 애플리케이션에 사용자가 요구를 입력한 시점부터 트랜잭션을 처리 후 그 결과의 출력이 완료할 때까지 걸리는 시간.
- 자원 사용률(Resource Usage)
  - 애플리케이션이 트랜잭션을 처리하는 동안 사용하는 CPU 사용량, 메모리 사용량, 네트워크 사용량.

### **★** 리팩토링

#### 리팩토링(Refactoring)의 개념

- 유지보수 생산성 향상을 목적으로 기능을 변경하지 않고, 복잡한 소스 코드를 수정, 보완하여 가용성 및 가독성을 높이는 기법이다.
- 소프트웨어 모듈의 외부적 기능은 수정하지 않고 내부적으로 구조, 관게 등을 단순화하여 소프트웨어의 유지보수성을 향상시키는 기법이다.

#### 리팩토링의 목적

- 유지보수성 향상
  - 복잡한 코드의 단순화, 소스의 가독성 향상.
- 유연한 시스템
  - 소프트웨어 요구사항 변경에 유연한 대응.
- 생산성 향상
  - 정제 및 최적화된 소스의 재사용.
- 품질 향상
  - 소프트웨어 오류발견이 용이하여 품질향상.
